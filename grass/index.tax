Organisation: global problems
	Notation: metalanguage-related
		Underuse: inferior substitutes are used instead of an available feature
		Overspec: the same constraint specified through several means
		Priorities: not present or circular
			Related: CMC|Cross-module Cycle
			Related: NL|No Layers
			Related: SS1|Stovepipe System
		Combo: double modifier creates an ambiguity
			Related: EUCF|Useless Control Flow
		Singleton: trivial choice, sequence or conjunction
			TODO other things with improper use of notation
			Related: IC|Incomplete Conditional
		Chant: comments cover up bad code
			TODO: explain why too much comments is a bad thing
			Related: CO|Comments
			Related: PDD|The Devil of Details
		Deprecated: the use of a feature that is no longer welcome
			Related: DSU|Deprecated Statement Usage
		Exotic: too idiosyncratic notational features decrease portability
			TODO: also people too attached to their tools or the ways their tools do it
			Related: VLI|Vendor Lock−In
			Related: GH|Golden Hammer
	Convention: violations of visual policies
		Formatting: misleading formatting
			Related: IPA|Improper Alignment
		Naming: problems with naming policies
			Several smells in one!
			Related: PNCN|Packages Not Clearly Named
			Related: DA|Duplicate Abstraction
			Related: INC|Inconsistent Naming Convention
			Related: IQU|Improper Quote Usage
		ZigZag: mixing horizontal and vertical styles
		Splat: nonterminal fragments scattered over the grammar
		Unnatural: a misspelling or improper use of the natural language
			Related: PSS|Stung by Spell-bee
	Parsing: parsing techniques related smells
		Factoring: improper factoring or distribution
			TODO: also when distinction is made deeper than conceptually should be
			Related: MH|Missing Hierarchy
			Related: ERC|Repeated Conditionals
		LeftRecursion: left recursive rules
			Related: CH|Cyclic Hierarchy
			Related: ESA|Self Assignment
		RightRecursion: right recursive rules
			Related: CH|Cyclic Hierarchy
			Related: ESA|Self Assignment
		Superset: parser spec is too relaxed
			Some grammars represent a superset of the intended language. This may become a problem if the parser based on the grammar is to be used as an oracle for program correctness, since in this role it is inadequate. Overly relaxed grammars are routinely used in other scenarios and can be very useful in inter-language translation.
			Related: OG|Overgeneralization
		Sloppy: a chunk of input could be parsed in more detail
			Related: MA|Missing Abstraction
			Related: MAC2|Missing Abstraction
		NoDefault: no error-localising default branch
			Related: MDC|Missing Default Case
			Related: AR|Assertion Roulette
		Action: a code smell in a semantic action
			Related: ESRA|Switch Redundant Assignment
			Related: PCTH|Circuitous Treasure Hunt
			Related: PEDA|Excessive Dynamic Allocation
			Related: POLB|The One Lane Bridge
			Related: MG|Mystery Guest
			Related: RO|Resource Optimism
			Related: IPV|Invalid Property Value
			Related: II|Inappropriate Intimacy
			Related: TQ|Type Queries
			Related: UE|Unexploited Encapsulation
			Related: OILS|Obscure In-Line Setup
	Duplication: the same fragment is repeated
		Echo: same rule occurs twice or more
		Clone: same right hand side occurs twice or more
			Related: DC2|Duplicate Code
			Related: RW|Reinvent the Wheel
			Related: CPP|Cut and Paste Programming
			Related: UH2|Unfactored Hierarchy
			Related: DE2|Duplicate Entity
		Foldable: nonterminal's right hand side is not unique
			Related: SPF|Scattered Parasitic Functionality
			Related: SAB|Subsystem-API Bypassed
			Related: GODY|The Grand Old Duke of York
			Related: BH|Broken Hierarchy
			Related: СBH|Broken Hierarchy
		Common: common subexpressions
			TODO: DC is when data is used together
			Related: DC|Data Clumps
			Related: RW|Reinvent the Wheel
			Related: DB|Duplicate Block
			Related: SDF|Duplicated Formulas
			Related: ACE|Connector Envy
		Permuted: permutations in commutative combinators
		Lookalike: near-clones
			Related: RW|Reinvent the Wheel
Navigation: problems with navigating through the grammar
	Spaghetti: scattering details over the grammar
		Uncluster: related nonterminals too far from one another
			Nonterminals that refer to one another, should be located close to one another
			Related: SC|Spaghetti Code
		Unsequence: confusing order of the production rules
			The order of the production rules in the grammar should be set up in a consistent manner, such that referred nonterminals in production rules refer either up or down in the grammar
			Related: SC|Spaghetti Code
		Start: the root symbol should not occur in the middle
			The starting symbol of the grammar should be on top or the bottom of the grammar, not in the middle
	Shortage: incompleteness
		Alphabet: seemingly incomplete collections
			The completeness of some character classes and terminal choices can be predicted, and compared to the actual value given by the grammar. For example, if a character class includes all Latin letters except one or all whitespace characters except <code>\r</code>, it may be an error. Similarly, if a preterminal is defined as a choice of all other alphanumeric terminals in the grammar (common for keyword definitions), then not a single one of them should be skipped.
		Entry: no starting symbol
		Dead: nonterminal defined, but not referenced
			Related: UP|Unused Packages
			Related: LF|Lava Flow
			Related: OC|Obsolete Classes
			Related: UA2|Unutilized Abstraction
			Related: EDLS|Dead Local Store
			Related: DF|Dead Fields
		Undefined: nonterminal referenced, but not defined
		NoModule: a missing module
		ToDo: incompletenesses covered up by todo/fixme comments
			Related: IT|Incomplete Tasks
	Mixture: spicing the grammar with alien fragments
		Layout: problems with whitespace and comments
		Preprocessor: combining parsing spec with preprocessor spec
Structure: harmful relationships among grammar components
	Proxy: indirect uses
		Chain: right hand side is a nonterminal
			Related: LC2|Lazy Class
			Related: EAC|Extraneous Adjacent Connector
			Related: MC|Message Chains
			Related: MM|Middle Man
			Related: SMM|Middle Man
			Related: SLCC|Long Calculation Chain
			Related: TML|Too Many Layers
		Throwaway: a nonterminal used only once
			Related: LIH|List-like Inheritance Hierarchy
			Related: POL|Poltergeist
			Related: IA|Imperative Abstraction
			Related: TDG|Tree-like Dependency Graph
		Weak: a nonterminal does not form a proper abstraction
			When the right hand side of a nonterminal is formed from several symbols that happen to occur one after another, without forming a proper abstraction, this can hinder grammar's understanding. The terminology is borrowed from TODO which distinguished strong nonterminals (used during parsing and present in the resulting tree) from weak ones (used during parsing but flattened into single nodes in the tree). (TODO in the paper with if/then/else)
			Related: IA2|Incomplete Abstraction
			Related: UA|Unnecessary Abstraction
			Related: UAC|Unnecessary Abstraction
			Related: DCA|Compound Attribute
			Related: DMA|Multicolumn Attribute
		Ghost: a subexpression that should have been a nonterminal
			Related: ME|Missing Encapsulation
		Multiexpert: a nonterminal that represents two or more concepts
			TODO violates the single responsibility principle
			Related: GC|God Class
			Related: PGC|God Class
			Related: SAK|Swiss Army Knife
			Related: MAC|Multifaceted Abstraction
			Related: PBB|Brother of the Bride
	Dependency: antipatterns in use
		Diamond: A is X and B is X, but C is A or B
			Related: AAI|Ambiguous Interfaces
		Rivalry: overlapping alternatives
			TODO: AS because it can be a result of parallelisation (???) and ACDI because it can parse the same thing differently
			Related: AS|Autogenerated Stovepipe
			Related: ACDI|Alternative Classes with Different Interfaces
			Related: ERC|Repeated Conditionals
		Ouroboros: a circular dependency among modules
			Related: DCP|Dependency Cycles between Packages/Subsystems
			Related: CM|Cyclically-dependent Modularization
			Related: SCDG|Static Cycles in Dependency Graphs
		Soulmates: nonterminals or modules are always changed together
			If enough information is available about the evolution of the grammar (e.g., in a form of a versioned repository or a piece of documentation describing all changes), one can notice two nonterminals having a so-called <emph>co-change relationship</emph> when each revision that changes one, also changes the other. The smell occurs when this co-change relationship in the revision log does not correspond to explicit dependencies between modules and nonterminals. TODO can be a thought experiment: if we do X, we must do Y; TODO actually can *only* be done with revision mining or conceptually, not by code analysis like usual for FE
			Related: CROSSM|Implicit Cross-Module Dependency
			Related: PIH|Parallel Inheritance Hierarchies
			Related: SS|Shotgun Surgery
			Related: SSS|Shotgun Surgery
			Related: FE|Feature Envy
			Related: SFE|Feature Envy
			Related: II|Inappropriate Intimacy
			Related: SII|Inappropriate Intimacy
		Spillover: a nonterminal that is too linked to the adjacent symbols
		Related: UINT|Unstable Interface
		Mythic: an alternative that is never exercised in the codebase
			Related: UH|Unnecessary Hierarchy
			Related: SG|Speculative Generality
			Related: SH|Speculative Hierarchy
	Complexity: metric-based smells
		TooWide: the width (right hand side length) is too big
			Related: SATL|Subsystem-API Too Large
			Related: LM|Long Method
			Related: LPL|Long Parameter List
			Related: CE|Complex Expression
			Related: LS|Long Statement
			Related: SMO|Multiple Operations
			Related: SMR|Multiple References
		TooRamose: too much branching
			TODO: conjunction, disjunction, relate to CC; TODO: WH suggests intermediate "types" but DCT/BM consider those a smell
			Related: WH|Wide Hierarchy
			Related: DCT|Clone Tables
			Related: SCC|Conditional Complexity
			Related: BM|Broken Modularization
		TooRecursive: too much recursion
		TooNested: groups are too deeply nested
			Related: AFC|Feature Concentration
		TooTall: the height (distance from the root) is too big
			Related: DH|Deep Hierarchy
			Related: TDIH|Too Deep Inheritance Hierarchy
		TooLonely: large non-modular grammar
			Related: NS|No Subsystems
			Related: IM|Insufficient Modularization
			Related: CIM|Insufficient Modularization
		TooModular: too many modules
			Related: TMS|Too Many Subsystems
			Related: TSP|Too Small Packages/Subsystems
		Greedy: one module that does too much
			Related: IM|Insufficient Modularization
			Related: TLP|Too Large Packages/Subsystems
			Related: LC|Large Class
			Related: BL|The Blob
		Lazy: one module that does not do much
			Related: LC2|Lazy Class
		TooCoupled: low cohesion and/or high coupling
			Related: CWM|Weakened Modularity
